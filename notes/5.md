### Функция

* Для эффективной разработки сложных (а на самом деле вообще любых) программных проектов важно уметь разбивать программу на отдельные части, которые впоследствии будут многократно использоваться.
* Одним из способов добиться повторного использования кода в Питоне - использование __функций__

* __Функция__ - это блок кода, который может вызваться из другой части программы, получить какие-то данные каким-то образом из обработать и вернуть в место, откуда была вызвана функция, результат обработки

*  Для объявления используется ключевое слово __def__, далее название и после аргументы в скобках

```python
def doubled(number):
    result = number * 2
    return result # Посчитанное число возвращается. Для этого используется ключевое слово return

# Важно: весь код функции в Питоне должен быть отделен пробелами или табами

a = 5
b = doubled(a) # Вызов функции. После того, 
               # как функция закончит свою рабту,  в b запишится вычисленное значение 10
c = doubled(20) # Повторный вызов

print(b, c, doubled(c)) # print - это кстати тоже функция.
```

```python
def doubled(number):
    return number * 2 # отдельная переменная result необязательна

print(doubled(10))
```

* Вообще говоря функция может не получать вообще никаких аргументов
* К примеру, функция __input()__, которая считывает пользовательский ввод и возвращает его ввиде строки
```python
a = input()
print(a)
```

* Функции, в которых нет return возвращают __None__
```python
def sayHello():
    print("Hello, User!")  
    
a = sayHello()
print(a)

# Hello, User!
# None
```

__Пример__: функция, считающая сумму натуральных чисел от 1 до n
```python
def sumTo(n):
    result = 0
    for i in range(1, n+1):
        result += i
    return result

print(sumTo(5)) # 15
```
* Все переменные, объявленные внутри функции являются локальными - то есть доступны только внутри функции

```python
def func1(a):
    variable = 2
    print(variable) # variable доступна внутри функции
    return a ** variable

print(func1(4))
print(variable) # variable не доступна вне функции

# 2
# 16
# NameError
```

* А вот функции напротив доступны переменные извне
```python
variable = 2

def func1(a):
    print(variable) # variable доступна внутри функции
    return a ** variable

print(func1(4))

# 2
# 16

```

* Функция также может вызывать саму себя внутри себя (__рекурсивно__)
* Классический пример: вычисление факториала числа (факториал - произведение чисел от 1 до n)

```python
def factorial(n):
    if n == 0 :
        return 1 # Факториал 0 мы считаем равным 1
    return n * factorial(n-1)
    
print(factorial(4)) # 24
```
* Важно: при использовании рекурсивных функций необходимо указать условие выхода. 
* В противном случае, функция будет бесконечно вызывать себя (точнее сказать до того, как закончится память)
* В данном примере, при достижении аргумента n нуля мы прекращаем рекурсию и возвращаем 1

***


* Одна из неприятных особенностей __рекурсивных функций__ - большое количество занимаемой памяти из-за того, что нужно хранить значения локальных переменных для каждого вызова функции
* Таким образом, если есть реализация функции не использующая рекурсивные вызовы - то в большинстве случаев лучше отдать предпочнение ей

```python
def factorial2(n): # Альтернативная реализация факториала, не использующая рекурсивные вызовы
    result = 1
    for i in range(1, n+1):
        result *= i
    return result

print(factorial2(4)) # 24
```

```python
def sumOfThree(a, b, c):
    return a + b + c

print(sumOfThree(3, 5, 7)) # 15
```

* Также у аргументов функции может быть значение по умолчанию - значение, которое принимает переменная если ее не передали

```python
def mmultiply(a, b = 10, c = 5):
    print("{0} {1} {2}".format(a, b, c))
    return a * b * c

print(mmultiply(1))
print(mmultiply(1, 2))
print(mmultiply(1, 2, 3))
```

* Функции, конечно же, могут принимать не только числовые значения в качестве агрументов

```python
def writeInColumn(string):
    for s in string:
        print(s)

writeInColumn("Some text")
```

* Функция вообще может принимать произвольное количество аргументов. Для этого необходимо поставить __*__ перед агрументом

```python
# numbers - это целый кортеж аргументов, которые были переданы в функцию
def sumOfNumbers(*numbers): 
    print(numbers)
    result = 0
    for n in numbers:
        result += n
    return result

print(sumOfNumbers(2, 3, 4))
# (2, 3, 4)
# 9

print(sumOfNumbers()) # Передасться пустой список
# ()
# 0

print(sumOfNumbers(2)) # Хоть аргумент всего один, передасться все равно кортеж с одним значением
# (2,)
# 2
```

* Важно: после аргумента для произвольного количества аргументов не может быть других агрументов

```python
def func2(*args, a, b, c):
    result = a + b + c
    for i in args:
        result += i
    return result

func2(2, 3, 4, 5, 6, 7)
# TypeError
```

* Интересный факт - сама функция является объектом
[визуализация](http://pythontutor.com/visualize.html#code=def%20add%28a,%20b%29%3A%0A%20%20%20%20return%20a%20%2B%20b%0Aa%20%3D%201&cumulative=false&curInstr=2&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)
```python
def add(a, b):
    return a + b

x = add # Важно: без скобок! Иначе вызовется сама функция и в x запишется не она, а результат ее работы

print(x) # <function add at 0x117f6f730>
print(x(3, 4)) # 7
```
